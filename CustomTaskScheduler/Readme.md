The code sample in this project shows how a custom Task Scheduler can be built in .Net. Basically, a task scheduler has a queue containing tasks and the scheduler overrides four methods from the abstract class `TaskScheduler`. Once, Task.Start is called, the `QueueTask` method of the scheduler is called. `QueueTask` can use ThreadPool maintained by the .Net framework or schedule the tasks on `Thread` which it itself creates. In this project, the `QueueTask` creates its own `Thread`. But [here](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskscheduler?view=netframework-4.7.2) is an example of how `ThreadPool's` `UnsafeQueueUserWorkItem` or `QueueUserWorkItem` can also be used.

#### What's the difference between using Thread and ThreadPool?
When you use Thread, you are basically spinning up a new Thread and it will exist till the delegate given to it finishes. Instead, you can use `ThreadPool` which is a .Net managed pool of threads which are always there and thus don't have spinning up overhead. But one should explicitly use any of `Thread` or `ThreadPool` only when writing a scheduler. Once the scheduler has been written, C# provides the functionality of `Tasks` using `async` and `await` keywords which automatically schedule Tasks on the Scheduler (be it the default TaskScheduler or any custom scheduler). [This blog](http://blog.stephencleary.com/2010/08/various-implementations-of-asynchronous.html) by Stephen Cleary describes the various implementations available to start asynchronous tasks in C#. Note that this blog discusses stuff in context of GUI applications but this is also true for normal console applications.
